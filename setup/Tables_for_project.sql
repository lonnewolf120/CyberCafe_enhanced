-- Table for Users
CREATE TABLE MCSC.Users (
    user_id VARCHAR2(20) PRIMARY KEY,
    first_name VARCHAR2(255) ,
    last_name VARCHAR2(255),
    email VARCHAR2(255) NOT NULL,
    password VARCHAR2(255) NOT NULL,
    account_type VARCHAR2(50) CHECK (account_type IN ('Admin', 'Student', 'Instructor')),
    contactNumber VARCHAR2(15),
    active CHAR(1) DEFAULT '0',
    approved CHAR(1) DEFAULT '0',
    --additional_details NUMBER,
    -- instead of having this as FK, we'll add user_id as fk to profile to get additional info
   
    image VARCHAR2(255),
    courses VARCHAR2(4000),
    course_progress VARCHAR2(4000)
    --CONSTRAINT fk_additional_details FOREIGN KEY (additional_details) REFERENCES Profile(profile_id)
    --CONSTRAINT fk_courses FOREIGN KEY (courses) REFERENCES Course_StudentsEnrolled(course_id)
);
-- Table for Profile
CREATE TABLE MCSC.Profile (
    profile_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id VARCHAR2(20) NOT NULL,
    gender VARCHAR2(50),
    date_of_birth DATE,
    about VARCHAR2(4000),
    contact_number VARCHAR2(50),
    CONSTRAINT fk_profile_userId FOREIGN KEY (user_id) REFERENCES MCSC.USERS(user_id) ON DELETE CASCADE
);

-- Recreate the sequences with the correct increment
CREATE SEQUENCE random_value_seq
  START WITH 412
  MINVALUE 412
  MAXVALUE 9999999
  NOCYCLE
  CACHE 200
  INCREMENT BY 1;

CREATE SEQUENCE incrementing_counter_seq
  START WITH 1
  MINVALUE 1
  MAXVALUE 9999999
  NOCYCLE
  CACHE 200
  INCREMENT BY 1;

-- Create trigger to generate primary key for Users table
CREATE OR REPLACE TRIGGER userid_key_trigger
BEFORE INSERT ON MCSC.USERS
FOR EACH ROW
BEGIN
  :NEW.user_id := TO_CHAR(LPAD(random_value_seq.NEXTVAL, 10, '0')    LPAD(incrementing_counter_seq.NEXTVAL, 7, '0'));
END;
/

--SHOW ERRORS TRIGGER userid_key_trigger;


-- Table for Category
-- RULE: No whitespace in between, use '-' instead and also all LOWERCASE
CREATE TABLE MCSC.Category (
    category_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR2(255) NOT NULL,
    description VARCHAR2(4000),
    courses VARCHAR2(4000)
);
--to find all courses under a category, find from the courses table with WHERE cateogry_id = :cat_id

-- Create a collection type for user IDs
--CREATE TYPE user_id_list AS TABLE OF NUMBER;

-- Table for Courses
CREATE TABLE MCSC.Courses (
    course_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    course_name VARCHAR2(255),
    course_description VARCHAR2(4000),
    instructor VARCHAR2(20) NOT NULL,
    what_you_will_learn VARCHAR2(4000),
    price NUMBER,
    thumbnail VARCHAR2(255),
    --courseContent 
    status VARCHAR2(10) CHECK (status IN ('Draft', 'Published')),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    category NUMBER,
    sold NUMBER DEFAULT 0,
    tag varchar2(100),
    instructions varchar2(200),
    CONSTRAINT fk_courses_instructor FOREIGN KEY (instructor) REFERENCES MCSC.Users(user_id) ON DELETE CASCADE,     --removed
    CONSTRAINT fk_courses_category FOREIGN KEY (category) REFERENCES MCSC.Category(category_id) ON DELETE CASCADE   --removed
   -- CONSTRAINT fk_
);
    
-- Associative table for Courses and Users (Many-to-Many for Students Enrolled)
CREATE TABLE MCSC.Course_StudentsEnrolled (
    course_id NUMBER,
    student_id VARCHAR2(20),
    PRIMARY KEY (course_id, student_id),
    CONSTRAINT fk_course_courseId FOREIGN KEY (course_id) REFERENCES MCSC.Courses(course_id) ON DELETE CASCADE,
    CONSTRAINT fk_student_userId FOREIGN KEY (student_id) REFERENCES MCSC.Users(user_id) ON DELETE CASCADE
);

-- Table for Section
CREATE TABLE MCSC.Section (
    section_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    course_id NUMBER,
    section_name VARCHAR2(255),
    subsection_id NUMBER,
    CONSTRAINT fk_section_courseId FOREIGN KEY (course_id) REFERENCES MCSC.Courses(course_id) ON DELETE CASCADE
);
-- Table for SubSection
CREATE TABLE MCSC.SubSection (
    subsection_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    section_id NUMBER,
    course_id NUMBER,
    title VARCHAR2(255),
    time_duration VARCHAR2(50),
    description VARCHAR2(4000),
    video_url VARCHAR2(255),
    CONSTRAINT fk_section_sectionId FOREIGN KEY (section_id) REFERENCES MCSC.Section(section_id) ON DELETE CASCADE,
    CONSTRAINT fk_subsection_courseId FOREIGN KEY (course_id) REFERENCES MCSC.COURSES(course_id) ON DELETE CASCADE
);


-- Table for CourseProgress
CREATE TABLE MCSC.CourseProgress (
    course_progress_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    course_id NUMBER,
    user_id VARCHAR2(20),
    completed_videos VARCHAR2(100),
    section_id NUMBER,
    SUBSECTION_ID NUMBER,
    CONSTRAINT fk_progress_sectionId FOREIGN KEY (section_id) REFERENCES MCSC.Section(section_id) ON DELETE CASCADE,
    CONSTRAINT fk_courseProgress_courseId FOREIGN KEY (course_id) REFERENCES MCSC.Courses(course_id) ON DELETE CASCADE,
    CONSTRAINT fk_courseProgress_userId FOREIGN KEY (user_id) REFERENCES MCSC.Users(user_id) ON DELETE CASCADE,
    CONSTRAINT fk_progress_subsectionId FOREIGN KEY (subsection_id) REFERENCES MCSC.SubSection(subsection_id) ON DELETE CASCADE
);

-- Table for OTP
CREATE TABLE MCSC.OTP (
    otp_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    email VARCHAR2(255) NOT NULL,
    otp VARCHAR2(50) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    expires_at TIMESTAMP GENERATED ALWAYS AS (created_at + INTERVAL '5' MINUTE)
);

CREATE TABLE MCSC.RatingAndReviews (
    rating_review_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id VARCHAR2(20),
    course_id NUMBER,
    review VARCHAR2(500),
    rating NUMBER,
    category_id NUMBER,
    CONSTRAINT fk_rating_review_course FOREIGN KEY (course_id) REFERENCES MCSC.Courses(course_id) ON DELETE CASCADE,
    CONSTRAINT fk_rating_user_review FOREIGN KEY (user_id) REFERENCES MCSC.Users(user_id) ON DELETE CASCADE,
     constraint fk_ratings_category FOREIGN KEY (category_id) references mcsc.category(CATEGORY_ID) ON DELETE CASCADE
);

----------------------NEW-----------------------
 CREATE TABLE MCSC.Instructor(
    instr_id VARCHAR2(20),
    courses NUMBER,
    CONSTRAINT fk_instr_course FOREIGN KEY (courses) REFERENCES MCSC.Courses(course_id) ON DELETE CASCADE,
    CONSTRAINT fk_instr_id FOREIGN KEY (instr_id) REFERENCES MCSC.Users(user_id) ON DELETE CASCADE  --removed
)

CREATE OR REPLACE TRIGGER trg_after_insert_course_instr
AFTER INSERT ON MCSC.Courses
FOR EACH ROW
BEGIN
  INSERT INTO MCSC.Instructor (instr_id, courses)
  VALUES (:NEW.instructor, :NEW.course_id);
END;
/


--ACOUNT 


Create table MCSC.Account
(
    Account_id  VARCHAR2(20) PRIMARY KEY,
    user_id VARCHAR2(20),
    Balance     NUMBER,
    Created_at  TIMESTAMP,
    Account_Type  VARCHAR2(20) CHECK (account_type IN ('Admin', 'Student', 'Instructor')),
    CONSTRAINT fk_account_userid FOREIGN KEY(USER_ID) REFERENCES MCSC.USERS(USER_ID) --REMOVED
);

-- FOR GENERATING THE USER ACCOUNT 
CREATE SEQUENCE RANDOM_VAL_ACC_1
START WITH 312
MINVALUE 312
MAXVALUE 999999
NOCYCLE
CACHE 200
INCREMENT BY 1;
CREATE SEQUENCE RANDOM_VAL_ACC_2
START WITH 091
MINVALUE 091
MAXVALUE 999999
NOCYCLE
CACHE 200
INCREMENT BY 1;
CREATE SEQUENCE RANDOM_VAL_ACC_3
START WITH 05
MINVALUE 05
MAXVALUE 9999999
NOCYCLE
CACHE 200
INCREMENT BY 2;

-- THE TRIGGER TO INSERT INTO THE USER ACCOUNT
CREATE OR REPLACE TRIGGER trg_insert_account
BEFORE INSERT ON MCSC.Account
FOR EACH ROW
BEGIN
    :NEW.ACCOUNT_ID := TO_CHAR(LPAD( RANDOM_VAL_ACC_1.NEXTVAL, 6, '0')) || TO_CHAR(LPAD( RANDOM_VAL_ACC_2.NEXTVAL, 6, '0')) || TO_CHAR(LPAD( RANDOM_VAL_ACC_3.NEXTVAL, 7, '0'));
END; 

-- TRIGGER TO CREATE ACCOUNT AS SOON AS A USER IS REGISTERED WITH 100 Coin Balance
CREATE OR REPLACE TRIGGER trg_create_account
AFTER INSERT ON MCSC.USERS
FOR EACH ROW
DECLARE
    v_userid VARCHAR2(100);
    v_type VARCHAR2(12);
BEGIN
    v_userid := :NEW.USER_ID;
    v_type := :NEW.ACCOUNT_TYPE;
    INSERT INTO MCSC.ACCOUNT (USER_ID, BALANCE, CREATED_AT, ACCOUNT_TYPE) 
    VALUES (v_userid, 100, SYSTIMESTAMP, v_type);
END;



-- the trxid here will be the JWT encoded string containing the user_id, account_id, amount and date
CREATE TABLE MCSC.TRX_HISTORY(
    TRXID VARCHAR2(100),
    USER_ID VARCHAR2(20),
    ACCOUNT_ID VARCHAR2(20),
    date_of_trx TIMESTAMP,
    amount_of_trx NUMBER,
    CONSTRAINT fk_trx_userid FOREIGN KEY(USER_ID) REFERENCES MCSC.USERS(USER_ID),
    CONSTRAINT fk_trx_account_id FOREIGN KEY(ACCOUNT_ID) REFERENCES MCSC.ACCOUNT(ACCOUNT_ID)
    )


CREATE TABLE MCSC.COURSE_BOUGHT
(
    COURSE_ID NUMBER(10),
    USER_ID VARCHAR2(20),
    TRXID VARCHAR2(100) ,
    PURCHASE_DATE TIMESTAMP 
);

CREATE OR REPLACE TYPE COURSE_ARRAY AS TABLE OF NUMBER;
/


CREATE OR REPLACE PROCEDURE create_payment (
    p_userid   IN  MCSC.ACCOUNT.USER_ID%TYPE,
    p_amount   IN  NUMBER,
    p_date     IN  VARCHAR2,
    p_courses  IN  course_array,  -- Array of course names or IDs
    p_message  OUT VARCHAR2,
    p_trxid    OUT VARCHAR2
) 
IS
    l_balance     NUMBER;
    l_account_id  MCSC.ACCOUNT.ACCOUNT_ID%TYPE;
BEGIN
    -- Fetch account data
    BEGIN
        SELECT BALANCE, ACCOUNT_ID 
        INTO l_balance, l_account_id
        FROM MCSC.ACCOUNT 
        WHERE USER_ID = p_userid;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            -- Create account if not exists
            INSERT INTO MCSC.ACCOUNT (USER_ID, BALANCE) 
            VALUES (p_userid, 100);
            COMMIT;
            -- Fetch the newly created account data
            SELECT BALANCE, ACCOUNT_ID 
            INTO l_balance, l_account_id
            FROM MCSC.ACCOUNT 
            WHERE USER_ID = p_userid;
    END;

    -- Check balance
    IF l_balance < p_amount THEN
        p_message := 'Insufficient Balance, current balance: ' || l_balance;
        RETURN;
    END IF;

    -- Deduct balance
    UPDATE MCSC.ACCOUNT 
    SET BALANCE = BALANCE - p_amount 
    WHERE USER_ID = p_userid;
    COMMIT;

    -- Generate a smaller TRXID (format: USERID_ACCOUNTID_YYYYMMDD)
    p_trxid := TO_CHAR(p_userid) || '_' || TO_CHAR(l_account_id) || '_' || REPLACE(SUBSTR(p_date, 1, 10), '-', '');

    -- Insert into TRX_HISTORY
    INSERT INTO MCSC.TRX_HISTORY (
        TRXID, USER_ID, ACCOUNT_ID, date_of_trx, amount_of_trx
    ) VALUES (
        p_trxid, p_userid, l_account_id, 
        TO_TIMESTAMP(p_date, 'YYYY-MM-DD HH24:MI:SS'), 
        p_amount
    );
    COMMIT;

    -- Insert each course from the array into a related table or process them as needed
    FOR i IN 1 .. p_courses.COUNT LOOP
        INSERT INTO MCSC.COURSE_BOUGHT (
            TRXID, USER_ID, COURSE_ID, PURCHASE_DATE
        ) VALUES (
            p_trxid, p_userid, p_courses(i),TO_TIMESTAMP(p_date, 'YYYY-MM-DD HH24:MI:SS')
        );
    END LOOP;
    COMMIT;

    p_message := 'Transaction successful';
EXCEPTION
    WHEN OTHERS THEN
        p_message := 'Transaction failed: ' || SQLERRM;
        ROLLBACK;
END;
/


        

----------------------CONTEST PART---------------------------

create table MCSC.Contest (
contestID NUMBER PRIMARY KEY NOT NULL,
contestName VARCHAR2(50) NOT NULL,
contestDesc VARCHAR2(150),
contestType VARCHAR2(50),
startTime TIMESTAMP,
endTime TIMESTAMP,
status NUMBER DEFAULT 0,
totalParticipant NUMBER,
totalSolves NUMBER
)

create table MCSC.Challenges (
cid NUMBER PRIMARY KEY NOT NULL,
c_title VARCHAR2(200),
c_content VARCHAR2(400),
Points NUMBER,
category VARCHAR2(100),
TASKURL VARCHAR2(150),
status NUMBER DEFAULT 0,
TASKNOTE VARCHAR2(150),
attempted NUMBER,
totalSolves NUMBER,
flag VARCHAR2(100),
contestID NUMBER,
CONSTRAINT fk_challenges_contest FOREIGN KEY (contestID) REFERENCES MCSC.Contest(contestID) ON DELETE CASCADE
)

CREATE TABLE MCSC.TaskList (
    "UID" NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    "PLATFORM" VARCHAR2(150),
    "TASKURL" VARCHAR2(100),
    "TASKNAME" VARCHAR2(200),
    "STATUS" VARCHAR2(20) DEFAULT 'Pending',
    "TASKNOTE" VARCHAR2(400),
    "TOTAL" NUMBER,
    "PENDING" NUMBER,
    "ATTEMPTED" NUMBER,
    "REVISIT" NUMBER,
    USER_ID VARCHAR2(30),

    CONSTRAINT fk_tasklist_userid FOREIGN KEY (USER_ID) REFERENCES MCSC.USERS(USER_ID) ON DELETE CASCADE
);

CREATE TABLE MCSC.Tokens(
    user_id VARCHAR2(20) NOT NULL,
    token VARCHAR2(255),
    created_at TIMESTAMP,
    expires_at TIMESTAMP,

    CONSTRAINT fk_tokens_userid FOREIGN KEY (user_id) REFERENCES MCSC.USERS (USER_ID) ON DELETE CASCADE
)

create table MCSC.practiceContent(
    PID NUMBER PRIMARY KEY NOT NULL,
    TITLE VARCHAR2(100) NOT NULL,
    URI VARCHAR2(200) NOT NULL,
    IMAGE VARCHAR2(200)
)
CREATE OR REPLACE TRIGGER trg_before_insert_practicecontent
BEFORE INSERT ON MCSC.PRACTICECONTENT
FOR EACH ROW
BEGIN
  :NEW.URI := 'http://localhost:5000/' || :NEW.URI;
END;
/






CREATE TABLE MCSC.HOST( --done
    host_id VARCHAR(20) NOT NULL,--ebhabe likhle hobe??
    user_id VARCHAR2(20),
    contestID NUMBER,
    CONSTRAINT fk_host_userid FOREIGN KEY (USER_ID) REFERENCES MCSC.USERS (USER_ID) ON DELETE CASCADE,
    CONSTRAINT fk_host_contestID FOREIGN KEY (contestID) REFERENCES MCSC.Contest(contestID) ON DELETE CASCADE
);




CREATE TABLE MCSC.TEAM(--done
    teamID VARCHAR (20) NOT NULL,
    t_name VARCHAR (20),
    member_ids VARCHAR (20), --Eta te problem ache mone hocche(multivalued)
    participant_id VARCHAR(20),
    CONSTRAINT fk_participation_id FOREIGN KEY (participant_id) REFERENCES MCSC.PARTICIPANT(participant_id) ON DELETE CASCADE
);

CREATE OR REPLACE TRIGGER insert_teamid
BEFORE INSERT ON MCSC.TEAM
FOR EACH ROW
BEGIN
  :NEW.teamID := TO_CHAR(LPAD(random_value_seq.NEXTVAL, 4, '0') || LPAD(incrementing_counter_seq.NEXTVAL, 4, '0'));
END;
/


CREATE TABLE MCSC.PARTICIPANT( --done
    participant_id VARCHAR(20) PRIMARY KEY,
    user_id VARCHAR2(20),
    teamID VARCHAR(20),
    contestID NUMBER,

    CONSTRAINT fk_participant_userid FOREIGN KEY (USER_ID) REFERENCES MCSC.USERS (USER_ID) ON DELETE CASCADE,
    CONSTRAINT fk_participant_teamID FOREIGN KEY (teamID) REFERENCES MCSC.TEAM(teamID) ON DELETE CASCADE,
    CONSTRAINT fk_participant_contestID FOREIGN KEY (contestID) REFERENCES MCSC.Contest(contestID) ON DELETE CASCADE
);
CREATE TABLE MCSC.SUBMISSION( --done
    submissionID VARCHAR (20) GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    penalty VARCHAR (20),
    submission_time VARCHAR (20),
    cid NUMBER,
    CONSTRAINT fk_cid FOREIGN KEY (cid) REFERENCES MCSC.Challenges(cid) ON DELETE CASCADE
);

CREATE TABLE MCSC.HINT( --done
    cost NUMBER,
    contest VARCHAR (20),
    Hstate VARCHAR (20),
    cid NUMBER ,
    CONSTRAINT fk_Hints_cid FOREIGN KEY (cid) REFERENCES MCSC.Challenges(CID) ON DELETE CASCADE
);

